[[!meta title="Git"]]
# Git

Git is a common distributed revision control system used by the OCF. Other common version control systems include Mercurial (also distributed) and Subversion (not distributed).

## Using Git

Recommended reading:

* [A Visual Git Reference](http://marklodato.github.com/visual-git-guide/)
* [The Case for Git Rebase](http://darwinweb.net/articles/the-case-for-git-rebase)

### Workflow

Although we use Git, a great tool for large-scale distributed development, for us a Subversion-like workflow with a "central repository" and linear history often makes more sense.

**Only commit your own, original work**.  You may commit another staff member's work if you have permission and change the author appropriately (e.g., `--author="Guest User <guser@ocf.berkeley.edu>"`). When committing, `git config user.name` should be your name and `git config user.email` should be your OCF email address -- this should be taken care of by [[LDAP]] and `/etc/mailname` on OCF machines.

#### To "update" your local branch to the latest changes from the central repository

    git pull --rebase

This will essentially (assuming the defaults, remote is `origin` and branch is `master`):

* update your local copy of the remote repository (`git fetch origin`)
* rewrite current branch in terms of tracked branch and rebased commits (`git rebase origin/master`)

The rebase prevents unnecessary merge commits by moving your local commits on top of the latest remote commit (`FETCH_HEAD`). This is a good thing if you have any local commits which have not yet been pushed to the remote repository. If you have "dirty" uncommitted changes, you'll need to commit them or stash them before rebasing (`git stash`).

The downside of a rebase is that it changes your current branch's history, which can be a problem if you've shared your branch and development has diverged. Avoid rebasing branches that have been published, such as the master branch in the central repository. Don't let this discourage you, however, from rebasing your local repository for a more usable history.

#### To "upload" your local changes to the central repository

    git add FILE # add current state of FILE in working tree to index
    git commit   # store index as a commit in current branch
    git push     # push current branch to tracked branch in remote repository

Use `git add -p` to inspect individual changes before adding each one to the index, and `git commit -v` to show a diff of your commit when it prompts you for a commit message.

If commits have been made on the remote repository in the meantime, you'll need to get those changes first before pushing (see above).

#### To "import" remote changes into the central repository

You would "import" remote changes when a staff member asks you to "pull" changes from a branch in his/her repository.

    git fetch REMOTE                             # update local copy of remote
    git status
    git log --graph --decorate FETCH_HEAD ^HEAD^ # list remote commits on top of current branch
    git diff FETCH_HEAD                          # compare current branch with remote branch
    git merge --ff-only FETCH_HEAD               # merge in remote branch if can linearly fast-forward

If you can't fast-forward merge, rebase the remote branch first to bring it up-to-date (see above).  Note that this will rewrite the remote branch's history. You can `git merge --no-ff` if you're certain you want a merge commit.

#### Other useful commands

Throw away uncommitted changes:

    git checkout -- FILE

Revise the last commit:

    git commit --amend

Undo the last commit (use the `--hard` option if you do not want to recommit your changes):

    git reset

File operations:

    git mv
    git rm

Advanced:

    git rebase -i     # rewrite history interactively
    git filter-branch # rewrite history according to a filter
    git blame         # show the commit which last modified each line of a file
    git reflog        # useful for undoing git mistakes

### Terminology

* branch
  * line of changes in a repository, default branch is `master`
* fast-forward
  * advance branch forward in a linear sequence
  * this is usually what we want: the new commit builds directly on the previous commit
* hooks
  * optional scripts that can be executed during git operations
  * for example, validate syntax before accepting a commit or deploy code to a server
* index (aka staging area)
  * files that are ready to be stored in your next commit
* references (aka refs)
  * SHA-1 hashes that identify commits
  * `HEAD` points to the latest commit ref in the current branch (`HEAD^` to the one before it)
* remote
  * upstream repository that you can `git fetch` from or `git push` to, default is `origin`
  * local branches can "track" remote branches (e.g., `master` tracking `origin/master`)
* working tree (aka workspace or working directory)
  * directory that checked out files reside
  * this includes the current branch and any "dirty" uncommitted changes (staged or not)
